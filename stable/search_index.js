var documenterSearchIndex = {"docs":
[{"location":"","page":"Home","title":"Home","text":"CurrentModule = EquivalenceClassesConstructor","category":"page"},{"location":"#EquivalenceClassesConstructor","page":"Home","title":"EquivalenceClassesConstructor","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"This code aims to provide a collection of methods that are able to exploit symmetries in arbitrary indexable objects over a given index set vl. For any indices x, y these symmetries must be known in the form of predicates,  i.e. p(x,y) &#8712; {true, false} or in form of mappings m(x) = y. The latter greatly increases performance but may lead to unexpected behavior with non monotonic mappings. The reason being that m(m(x)) may lie in vl but m(x)) may not, forcing the algorithm to terminate.","category":"page"},{"location":"#Index","page":"Home","title":"Index","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"","category":"page"},{"location":"","page":"Home","title":"Home","text":"Modules = [EquivalenceClassesConstructor]","category":"page"},{"location":"#EquivalenceClassesConstructor.EquivalenceClasses-Tuple{Mapping,AbstractArray}","page":"Home","title":"EquivalenceClassesConstructor.EquivalenceClasses","text":"EquivalenceClasses(m::Mapping, vl::AbstractArray)\n\nConstructs an EquivalenceClasses struct from a mapping m over the indices in the list vl. sorted can be set to true to force all lists of mappings  between classes to be sorted\n\nExamples\n\njulia> EquivalenceClasses(Predicate((x,y)->all(x .== -y)),\n                          [(i,j) for i in -2:2 for j in 4:7])\n\n\n\n\n\n","category":"method"},{"location":"#EquivalenceClassesConstructor.EquivalenceClasses-Tuple{Predicate,AbstractArray}","page":"Home","title":"EquivalenceClassesConstructor.EquivalenceClasses","text":"EquivalenceClasses(pred::Predicate, vl::AbstractArray)\n\nConstructs an EquivalenceClasses struct from a predicate pred over n indices in the list vl. This inputs requires n^2 operations in order to create the adjecency matrix. For large inputs a mapping is therefore  preferabel. sorted can be set to true to force all lists of mappings  between classes to be sorted\n\nExamples\n\njulia> EquivalenceClasses(Predicate((x,y)->all(x .== -y)),\n                          [(i,j) for i in -2:2 for j in 4:7])\n\n\n\n\n\n","category":"method"},{"location":"#EquivalenceClassesConstructor.build_adj_matrix-Tuple{Predicate,Any}","page":"Home","title":"EquivalenceClassesConstructor.build_adj_matrix","text":"build_adj_matrix(pred, vl)\n\nConstructs adjacency matrix with vertices from vl and edges from pred(i,j) where i,j âˆˆ vl\n\n\n\n\n\n","category":"method"},{"location":"#EquivalenceClassesConstructor.check_for_equivalence_relation-Tuple{Predicate,Any}","page":"Home","title":"EquivalenceClassesConstructor.check_for_equivalence_relation","text":"check_for_equivalence_relation(f::Predicate, dom)\n\nGiven a Predicate f over a domain dom, return true if f is a equivalence relation, false otherwise. One can create a symmetric equivalency relation with make_symmetric(f) TODO: check transitivity.\n\nExamples\n\njulia> check_for_equivalence_relation(Predicate((x,y) -> x == -y), -5:10)\ntrue\njulia> check_for_equivalence_relation(Predicate((x,y) -> x == y+2), -1:10)\nfalse\n\n\n\n\n\n","category":"method"},{"location":"#EquivalenceClassesConstructor.find_classes-Tuple{BitArray{2}}","page":"Home","title":"EquivalenceClassesConstructor.find_classes","text":"find_classes(adj::BitArray{2})\n\nreturns an array of length size(adj,1) with each entry with index i being a unique identifier for the equivalency class of the node i. Uses adjacency matrix as input. I.e. graph needs to be constructed before.\n\nExamples\n\njulia> find_classes(convert(BitArray, [0 1 0; 1 0 0; 0 0 0]))\n[1, 1, 2]\n\n\n\n\n\n","category":"method"},{"location":"#EquivalenceClassesConstructor.find_classes-Tuple{Predicate,AbstractArray}","page":"Home","title":"EquivalenceClassesConstructor.find_classes","text":"find_classes(pred::Predicate, vl; isSymmetric=false)\n\nreturns an array of length length(vl) with each entry with index i being a unique identifier for the equivalency class of the node i. See find_classes(m::Mapping, vl) for more information.\n\n\n\n\n\n","category":"method"},{"location":"#EquivalenceClassesConstructor.find_classes-Union{Tuple{T}, Tuple{Mapping,AbstractArray{T,1}}} where T","page":"Home","title":"EquivalenceClassesConstructor.find_classes","text":"find_classes(m::Mapping, vl; vl_len=length(vl), sorted=false)\n\nreturns an array of length size(adj,1) with each entry with index i being a unique identifier for the equivalency class of the node i. Uses a mapping function m(x) = y and an vertex list vl to construct graph i n place. m has to be symmetric (i.e. m(x) = y => m(y) = x)! In case the vertex list is closed under the mapping (i.e. there exist no x in  vl such that m(x) is not in vl), closed can be set to false in order to improve performace. vl_len can be specified explicitly in cases where length(vl) does not work  (e.g. nested generator objects). The boolean sorted can be set to true, if the resulting expand map should be  sorted (one should make sure, that the elements of vl are comparable). For performace reasons this function can also be called with a normal Julia function instead of Mapping\n\nExamples\n\njulia> find_classes(Mapping(x-> [-x]), -2:4)\n\"IndexMapping{Int64}[Full: -2:4, ExpandMap: Dict(0 => [0],4 => [4],-2 => [-2, 2],-1 => [-1, 1],3 => [3])]\"\n\n\n\n\n\n","category":"method"}]
}
