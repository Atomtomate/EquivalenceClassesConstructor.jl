var documenterSearchIndex = {"docs":
[{"location":"","page":"Home","title":"Home","text":"CurrentModule = EquivalenceClassesConstructor","category":"page"},{"location":"#EquivalenceClassesConstructor","page":"Home","title":"EquivalenceClassesConstructor","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"This code aims to provide a collection of methods that are able to exploit symmetries in arbitrary indexable objects over a given index set vl. For any indices x, y these symmetries must be known in the form of predicates,  i.e. p(x,y) &#8712; {true, false} or in form of mappings m(x) = y. The latter greatly increases performance but may lead to unexpected behavior with non monotonic mappings. The reason being that m(m(x)) may lie in vl but m(x)) may not, forcing the algorithm to terminate.","category":"page"},{"location":"#Index","page":"Home","title":"Index","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"","category":"page"},{"location":"","page":"Home","title":"Home","text":"Modules = [EquivalenceClassesConstructor]","category":"page"},{"location":"#EquivalenceClassesConstructor.EquivalenceClasses-Tuple{Mapping,AbstractArray}","page":"Home","title":"EquivalenceClassesConstructor.EquivalenceClasses","text":"EquivalenceClasses(m::Mapping, indl::AbstractArray)\n\nConstructs an EquivalenceClasses struct from a mapping m over the indices in the list indl.\n\nExamples\n\njulia> EquivalenceClasses(Predicate((x,y)->all(x .== -y)),\n                          [(i,j) for i in -2:2 for j in 4:7])\n\n\n\n\n\n","category":"method"},{"location":"#EquivalenceClassesConstructor.EquivalenceClasses-Tuple{Predicate,AbstractArray}","page":"Home","title":"EquivalenceClassesConstructor.EquivalenceClasses","text":"EquivalenceClasses(pred::Predicate, indl::AbstractArray)\n\nConstructs an EquivalenceClasses struct from a predicate pred over n indices in the list indl. This inputs requires n^2 operations in order to create the adjecency matrix. For large inputs a mapping is therefore  preferabel.\n\nExamples\n\njulia> EquivalenceClasses(Predicate((x,y)->all(x .== -y)),\n                          [(i,j) for i in -2:2 for j in 4:7])\n\n\n\n\n\n","category":"method"},{"location":"#EquivalenceClassesConstructor.build_adj_matrix-Tuple{Predicate,Any}","page":"Home","title":"EquivalenceClassesConstructor.build_adj_matrix","text":"build_adj_matrix(pred, indl)\n\nConstructs adjacency matrix with vertices from indl and edges from pred(i,j) where i,j âˆˆ indl\n\n\n\n\n\n","category":"method"},{"location":"#EquivalenceClassesConstructor.check_for_equivalence_relation-Tuple{Predicate,Any}","page":"Home","title":"EquivalenceClassesConstructor.check_for_equivalence_relation","text":"check_for_equivalence_relation(f::Predicate, dom)\n\nGiven a Predicate f over a domain dom, return true if f is a equivalence relation, false otherwise. One can create a symmetric equivalency relation with make_symmetric(f) TODO: check transitivity.\n\nExamples\n\njulia> check_for_equivalence_relation(Predicate((x,y) -> x == -y), -5:10)\ntrue\njulia> check_for_equivalence_relation(Predicate((x,y) -> x == y+2), -1:10)\nfalse\n\n\n\n\n\n","category":"method"},{"location":"#EquivalenceClassesConstructor.find_classes-Tuple{BitArray{2}}","page":"Home","title":"EquivalenceClassesConstructor.find_classes","text":"find_classes(adj::BitArray{2})\n\nreturns an array of length size(adj,1) with each entry with index i being a unique identifier for the equivalency class of the node i. Uses adjacency matrix as input. I.e. graph needs to be constructed before.\n\nExamples\n\njulia> find_classes(convert(BitArray, [0 1 0; 1 0 0; 0 0 0]))\n[1, 1, 2]\n\n\n\n\n\n","category":"method"},{"location":"#EquivalenceClassesConstructor.find_classes-Tuple{Mapping,AbstractArray}","page":"Home","title":"EquivalenceClassesConstructor.find_classes","text":"find_classes(m::Mapping, vl)\n\nreturns an array of length size(adj,1) with each entry with index i being a unique identifier for the equivalency class of the node i. Uses a mapping function m(x) = y and an vertex list vl to construct graph i n place. m has to be symmetric (i.e. m(x) = y => m(y) = x)! In case the vertex list is closed under the mapping (i.e. there exist no x in  vl such that m(x) is not in vl), closed can be set to false in order to improve performace.\n\nExamples\n\njulia> find_classes(Mapping(x-> [-x]), -2:4)\nDict(0 => 3,4 => 5,2 => 1,-2 => 1,-1 => 2,3 => 4,1 => 2)\n\n\n\n\n\n","category":"method"},{"location":"#EquivalenceClassesConstructor.find_classes-Tuple{Predicate,AbstractArray}","page":"Home","title":"EquivalenceClassesConstructor.find_classes","text":"find_classes(pred::Predicate, indl; isSymmetric=false)\n\nreturns an array of length length(indl) with each entry with index i being a unique identifier for the equivalency class of the node i.\n\n\n\n\n\n","category":"method"}]
}
